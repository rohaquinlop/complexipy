{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"complexipy","text":"<p>Blazingly fast cognitive complexity analysis for Python, written in Rust.</p> <p> </p> <p> Installation \u2022     Quick Start \u2022     Integrations \u2022     Documentation </p>"},{"location":"#what-is-cognitive-complexity","title":"What is Cognitive Complexity?","text":"<p>Cognitive complexity measures how hard code is to understand by humans, not machines.</p> <p>Unlike traditional metrics like cyclomatic complexity, cognitive complexity accounts for nesting depth and control flow patterns that affect human comprehension. Inspired by G. Ann Campbell's research at SonarSource, complexipy provides a fast, accurate implementation for Python.</p> <p>Key benefits: - Human-focused - Penalizes nesting, flow breaks, and human-unfriendly logic - Actionable insights - Identifies genuinely hard-to-maintain code - Different from cyclomatic - Measures readability while cyclomatic measures structural, testing, and branch density</p>"},{"location":"#common-questions","title":"Common Questions","text":"<p>How is complexity calculated? Learn about the scoring algorithm, what each control structure contributes, and how nesting affects the final score.</p> <p>How does this compare to Ruff's PLR0912? Understand the key differences between cyclomatic complexity (Ruff) and cognitive complexity (complexipy), and why you might want to use both.</p> <p>Is this a SonarSource/Sonar product? No. complexipy is an independent project inspired by G. Ann Campbell's research, but it's not affiliated with or endorsed by SonarSource.</p>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install complexipy\n# or\nuv add complexipy\n</code></pre>"},{"location":"#quick-start","title":"Quick Start","text":""},{"location":"#command-line","title":"Command Line","text":"<pre><code># Analyze current directory\ncomplexipy .\n\n# Analyze specific file/directory\ncomplexipy path/to/code.py\n\n# Analyze with custom threshold\ncomplexipy . --max-complexity-allowed 10\n\n# Save results to JSON/CSV\ncomplexipy . --output-json --output-csv\n\n# Analyze current directory while excluding specific files\ncomplexipy . --exclude path/to/exclude.py --exclude path/to/other/exclude.py\n</code></pre>"},{"location":"#python-api","title":"Python API","text":"<pre><code>from complexipy import file_complexity, code_complexity\n\n# Analyze a file\nresult = file_complexity(\"app.py\")\nprint(f\"File complexity: {result.complexity}\")\n\nfor func in result.functions:\n    print(f\"{func.name}: {func.complexity}\")\n\n# Analyze code string\nsnippet = \"\"\"\ndef complex_function(data):\n    if data:\n        for item in data:\n            if item.is_valid():\n                process(item)\n\"\"\"\n\nresult = code_complexity(snippet)\nprint(f\"Complexity: {result.complexity}\")\n</code></pre>"},{"location":"#integrations","title":"Integrations","text":"\ud83d\udd27 GitHub Actions <pre><code>- uses: rohaquinlop/complexipy-action@v2\n  with:\n    paths: .\n    max_complexity_allowed: 10\n    output_json: true\n</code></pre> \ud83e\ude9d Pre-commit Hook <pre><code>repos:\n- repo: https://github.com/rohaquinlop/complexipy-pre-commit\n  rev: v4.2.0\n  hooks:\n    - id: complexipy\n</code></pre> \ud83d\udd0c VS Code Extension  Install from the [marketplace](https://marketplace.visualstudio.com/items?itemName=rohaquinlop.complexipy) for real-time complexity analysis with visual indicators."},{"location":"#configuration","title":"Configuration","text":""},{"location":"#toml-configuration-files","title":"TOML Configuration Files","text":"<p>complexipy supports configuration via TOML files. Configuration files are loaded in this order of precedence:</p> <ol> <li><code>complexipy.toml</code> (project-specific config)</li> <li><code>.complexipy.toml</code> (hidden config file)</li> <li><code>pyproject.toml</code> (under <code>[tool.complexipy]</code> section)</li> </ol>"},{"location":"#example-configuration","title":"Example Configuration","text":"<pre><code># complexipy.toml or .complexipy.toml\npaths = [\"src\", \"tests\"]\nmax-complexity-allowed = 10\nsnapshot-create = false\nsnapshot-ignore = false\nquiet = false\nignore-complexity = false\nfailed = false\ncolor = \"auto\"\nsort = \"asc\"\nexclude = []\noutput-csv = false\noutput-json = false\n</code></pre> <pre><code># pyproject.toml\n[tool.complexipy]\npaths = [\"src\", \"tests\"]\nmax-complexity-allowed = 10\nsnapshot-create = false\nsnapshot-ignore = false\nquiet = false\nignore-complexity = false\nfailed = false\ncolor = \"auto\"\nsort = \"asc\"\nexclude = []\noutput-csv = false\noutput-json = false\n</code></pre>"},{"location":"#cli-options","title":"CLI Options","text":"Flag Description Default <code>--exclude</code> Exclude entries relative to each provided path. Entries resolve to existing directories (prefix match) or files (exact match). Non-existent entries are ignored. <code>--max-complexity-allowed</code> Complexity threshold <code>15</code> <code>--snapshot-create</code> Save the current violations above the threshold into <code>complexipy-snapshot.json</code> <code>false</code> <code>--snapshot-ignore</code> Skip comparing against the snapshot even if it exists <code>false</code> <code>--failed</code> Show only functions above the complexity threshold <code>false</code> <code>--color &lt;auto\\|yes\\|no&gt;</code> Use color <code>auto</code> <code>--sort &lt;asc\\|desc\\|name&gt;</code> Sort results <code>asc</code> <code>--quiet</code> Suppress output <code>false</code> <code>--ignore-complexity</code> Don't exit with error on threshold breach <code>false</code> <code>--version</code> Show installed complexipy version and exit - <code>--output-json</code> Save results as JSON <code>false</code> <code>--output-csv</code> Save results as CSV <code>false</code> <p>Example:</p> <pre><code># Exclude only top-level 'tests' directory under the provided root\ncomplexipy . --exclude tests\n# This will not exclude './complexipy/utils.py' if you pass '--exclude utils' at repo root,\n# because there is no './utils' directory or file at that level.\n</code></pre>"},{"location":"#snapshot-baselines","title":"Snapshot Baselines","text":"<p>Use snapshots to adopt complexipy in large, existing codebases without touching every legacy function at once.</p> <pre><code># Record the current state (creates complexipy-snapshot.json in the working directory)\ncomplexipy . --snapshot-create --max-complexity-allowed 15\n\n# Block regressions while allowing previously-recorded functions\ncomplexipy . --max-complexity-allowed 15\n\n# Temporarily skip the snapshot gate\ncomplexipy . --snapshot-ignore\n</code></pre> <p>The snapshot file only stores functions whose complexity exceeds the configured threshold. When a snapshot file exists, complexipy will automatically:</p> <ul> <li>fail if a new function crosses the threshold,</li> <li>fail if a tracked function becomes more complex, and</li> <li>pass (and update the snapshot) when everything is stable or improved, automatically removing entries that now meet the standard.</li> </ul> <p>Use <code>--snapshot-ignore</code> if you need to temporarily bypass the snapshot gate (for example during a refactor or while regenerating the baseline).</p>"},{"location":"#inline-ignores","title":"Inline Ignores","text":"<p>You can explicitly ignore a known complex function inline, similar to Ruff's <code>C901</code> ignores:</p> <pre><code>def legacy_adapter(x, y):  # noqa: complexipy (safe wrapper)\n    if x and y:\n        return x + y\n    return 0\n</code></pre> <p>Place <code># noqa: complexipy</code> on the function definition line (or the line immediately above). An optional reason can be provided in parentheses or plain text, it\u2019s ignored by the parser.</p>"},{"location":"#api-reference","title":"API Reference","text":"<pre><code># Core functions\nfile_complexity(path: str) -&gt; FileComplexity\ncode_complexity(source: str) -&gt; CodeComplexity\n\n# Return types\nFileComplexity:\n  \u251c\u2500 path: str\n  \u251c\u2500 complexity: int\n  \u2514\u2500 functions: List[FunctionComplexity]\n\nFunctionComplexity:\n  \u251c\u2500 name: str\n  \u251c\u2500 complexity: int\n  \u251c\u2500 line_start: int\n  \u2514\u2500 line_end: int\n</code></pre> <sub>Inspired by the Cognitive Complexity research by G. Ann Campbell</sub> <sub>complexipy is an independent project and is not affiliated with or endorsed by SonarSource</sub>  **[Documentation](https://rohaquinlop.github.io/complexipy/) \u2022 [PyPI](https://pypi.org/project/complexipy/) \u2022 [GitHub](https://github.com/rohaquinlop/complexipy)**  <sub>Built with \u2764\ufe0f by @rohaquinlop and contributors</sub>"},{"location":"about/","title":"About complexipy","text":""},{"location":"about/#origins-and-inspiration","title":"Origins and Inspiration","text":"<p>complexipy is inspired by the Cognitive Complexity research paper by G. Ann Campbell from SonarSource. This groundbreaking work introduced a new approach to measuring code complexity that better aligns with human understanding.</p> <p>Independent Project</p> <p>While complexipy implements the cognitive complexity methodology described in Campbell's research, it is not affiliated with or endorsed by SonarSource or Sonar products. complexipy is an independent, open-source implementation written in Rust for Python code analysis.</p>"},{"location":"about/#why-cognitive-complexity","title":"Why Cognitive Complexity?","text":"<p>Cyclomatic complexity measures code structural, testing, and branch density (number of paths) by counting decision points. However, this doesn't reflect how humans actually understand code. Cognitive complexity measures how difficult code is for humans to understand and maintain by penalizing nesting, flow breaks, and human-unfriendly logic.</p>"},{"location":"about/#different-approaches-to-measuring-complexity","title":"Different Approaches to Measuring Complexity","text":"<p>Cyclomatic complexity (McCabe, 1976) counts every decision point:</p> <pre><code># Cyclomatic complexity: 4\ndef example1(a, b, c):\n    if a:\n        return 1\n    if b:\n        return 2\n    if c:\n        return 3\n    return 4\n</code></pre> <pre><code># Cyclomatic complexity: 4 (same as above!)\ndef example2(a, b, c):\n    if a:\n        if b:\n            if c:\n                return 1\n    return 4\n</code></pre> <p>Both functions have the same cyclomatic complexity, but any developer will tell you <code>example2</code> is much harder to understand.</p>"},{"location":"about/#the-cognitive-complexity-solution","title":"The Cognitive Complexity Solution","text":"<p>Cognitive complexity accounts for nesting:</p> <pre><code># Cognitive complexity: 3\ndef example1(a, b, c):\n    if a:        # +1\n        return 1\n    if b:        # +1\n        return 2\n    if c:        # +1\n        return 3\n    return 4\n</code></pre> <pre><code># Cognitive complexity: 6\ndef example2(a, b, c):\n    if a:        # +1\n        if b:    # +2 (1 + nesting_level)\n            if c:  # +3 (1 + nesting_level)\n                return 1\n    return 4\n</code></pre> <p>This aligns with human intuition: nested code requires holding more context in your mind.</p>"},{"location":"about/#project-goals","title":"Project Goals","text":"<ol> <li>Performance - Blazingly fast analysis using Rust</li> <li>Accuracy - Faithful implementation of cognitive complexity principles</li> <li>Accessibility - Easy integration with Python development workflows</li> <li>Actionability - Clear, actionable insights for improving code quality</li> </ol>"},{"location":"about/#the-team","title":"The Team","text":"<p>complexipy is built with \u2764\ufe0f by @rohaquinlop and contributors.</p>"},{"location":"about/#license","title":"License","text":"<p>complexipy is released under the MIT License.</p>"},{"location":"comparison-with-ruff/","title":"Comparison with Ruff","text":""},{"location":"comparison-with-ruff/#overview","title":"Overview","text":"<p>Both Ruff and complexipy help improve Python code quality, but they measure different aspects of complexity and serve complementary purposes. Ruff's PLR0912 measures structural complexity, testing, and branch density, while complexipy measures how difficult code is for humans to understand and maintain.</p>"},{"location":"comparison-with-ruff/#ruffs-plr0912-too-many-branches","title":"Ruff's PLR0912: Too Many Branches","text":"<p>Ruff's PLR0912 (too-many-branches) rule is based on cyclomatic complexity and counts the number of decision points in a function.</p>"},{"location":"comparison-with-ruff/#how-ruff-counts-branches","title":"How Ruff Counts Branches","text":"<p>Ruff counts each of these as a branch: - <code>if</code>, <code>elif</code>, <code>else</code> statements - <code>for</code> and <code>while</code> loops - <code>and</code>, <code>or</code> boolean operators - <code>except</code> clauses - Pattern matching cases</p> <p>The default threshold is typically 12 branches per function.</p>"},{"location":"comparison-with-ruff/#example-ruff-analysis","title":"Example: Ruff Analysis","text":"<pre><code>def example(a, b, c, d):\n    if a:           # Branch 1\n        return 1\n    elif b:         # Branch 2\n        return 2\n    elif c:         # Branch 3\n        return 3\n    elif d:         # Branch 4\n        return 4\n    else:           # Branch 5\n        return 0\n# Ruff: 5 branches\n</code></pre>"},{"location":"comparison-with-ruff/#complexipy-cognitive-complexity","title":"complexipy: Cognitive Complexity","text":"<p>complexipy implements cognitive complexity, which weights branches by their nesting level to reflect human understanding.</p>"},{"location":"comparison-with-ruff/#how-complexipy-scores","title":"How complexipy Scores","text":"<p>complexipy uses the formula: <code>complexity = base_score + nesting_level</code></p> <pre><code>def example(a, b, c, d):\n    if a:           # +1 (1 + 0 nesting)\n        return 1\n    elif b:         # +1 (elif counts as +1)\n        return 2\n    elif c:         # +1\n        return 3\n    elif d:         # +1\n        return 4\n    else:           # +0 (else doesn't add base score)\n        return 0\n# complexipy: 4 points\n</code></pre>"},{"location":"comparison-with-ruff/#key-differences","title":"Key Differences","text":""},{"location":"comparison-with-ruff/#1-nesting-is-critical-in-complexipy","title":"1. Nesting is Critical in complexipy","text":"<p>Ruff treats all branches equally: <pre><code># Ruff: 3 branches\ndef flat_logic(a, b, c):\n    if a:           # Branch 1\n        return 1\n    if b:           # Branch 2\n        return 2\n    if c:           # Branch 3\n        return 3\n</code></pre></p> <pre><code># Ruff: 3 branches (same as above)\ndef nested_logic(a, b, c):\n    if a:           # Branch 1\n        if b:       # Branch 2\n            if c:   # Branch 3\n                return 1\n</code></pre> <p>complexipy accounts for nesting: <pre><code># complexipy: 3 points\ndef flat_logic(a, b, c):\n    if a:           # +1\n        return 1\n    if b:           # +1\n        return 2\n    if c:           # +1\n        return 3\n</code></pre></p> <pre><code># complexipy: 6 points (much worse!)\ndef nested_logic(a, b, c):\n    if a:           # +1 (1 + 0)\n        if b:       # +2 (1 + 1)\n            if c:   # +3 (1 + 2)\n                return 1\n</code></pre>"},{"location":"comparison-with-ruff/#2-else-clauses","title":"2. else Clauses","text":"<p>Ruff: Counts <code>else</code> as a branch (+1)</p> <p>complexipy: <code>else</code> doesn't add base complexity, only nesting penalty</p> <pre><code># Ruff: 2 branches\n# complexipy: 1 point\ndef check(value):\n    if value &gt; 0:   # Ruff: +1, complexipy: +1\n        return \"positive\"\n    else:           # Ruff: +1, complexipy: +0\n        return \"non-positive\"\n</code></pre>"},{"location":"comparison-with-ruff/#3-boolean-operators","title":"3. Boolean Operators","text":"<p>Both count boolean operators, but with different philosophies:</p> <p>Ruff: Counts each <code>and</code>/<code>or</code> as a separate branch</p> <p>complexipy: Counts operators and penalizes mixed operator types</p> <pre><code># Ruff: 3 branches (if + and + or)\n# complexipy: 3 points (1 for if, +2 for boolean ops)\ndef check(a, b, c):\n    if a and b or c:\n        return True\n</code></pre>"},{"location":"comparison-with-ruff/#4-match-statements-python-310","title":"4. Match Statements (Python 3.10+)","text":"<p>Ruff: Counts each <code>case</code> as a branch</p> <p>complexipy: Match itself adds no complexity, only nested content counts</p> <pre><code># Ruff: 3 branches (match + 2 cases)\n# complexipy: 2 points (only the nested ifs)\nmatch value:        # Ruff: +1, complexipy: +0\n    case 1:         # Ruff: +1, complexipy: +0\n        if x:       # Ruff: +1, complexipy: +1\n            pass\n    case 2:         # Already counted by Ruff\n        if y:       # complexipy: +1\n            pass\n</code></pre>"},{"location":"comparison-with-ruff/#practical-comparison-example","title":"Practical Comparison Example","text":"<p>Here's a real-world scenario showing how the two tools differ:</p> <pre><code>def process_payment(order):\n    if order is None:                              # Ruff: 1, complexipy: 1\n        return False\n\n    if not order.is_valid():                       # Ruff: 2, complexipy: 2\n        return False\n\n    if order.payment_method == \"credit_card\":      # Ruff: 3, complexipy: 3\n        if order.amount &gt; 1000:                    # Ruff: 4, complexipy: 5 (1+1 nesting)\n            if not verify_fraud_check(order):      # Ruff: 5, complexipy: 8 (1+2 nesting)\n                return False\n        return process_credit_card(order)\n    elif order.payment_method == \"paypal\":         # Ruff: 6, complexipy: 4\n        return process_paypal(order)\n    else:                                           # Ruff: 7, complexipy: 4\n        return False\n\n# Final Scores:\n# Ruff: 7 branches\n# complexipy: 8 points\n</code></pre> <p>In this example: - Ruff flags the function for having 7 branches (over typical threshold) - complexipy gives it 8 points, with most complexity coming from the nested fraud check - complexipy better identifies that the deeply nested fraud check is the problematic part</p>"},{"location":"comparison-with-ruff/#which-should-you-use","title":"Which Should You Use?","text":""},{"location":"comparison-with-ruff/#use-ruff-plr0912-when","title":"Use Ruff (PLR0912) When:","text":"<ul> <li>You need to measure structural complexity and branch density</li> <li>You're designing test coverage strategies</li> <li>You want to limit the absolute number of decision points</li> <li>You're already using Ruff for other linting</li> </ul>"},{"location":"comparison-with-ruff/#use-complexipy-when","title":"Use complexipy When:","text":"<ul> <li>You want to identify code that's hard for humans to understand</li> <li>You're focused on code readability and maintainability</li> <li>Nesting and flow complexity are concerns in your codebase</li> <li>You're conducting code reviews focused on comprehension</li> </ul>"},{"location":"comparison-with-ruff/#use-both-recommended","title":"Use Both! (Recommended)","text":"<p>Ruff and complexipy are complementary:</p> <pre><code># In your pre-commit or CI pipeline\nruff check . --select=PLR0912  # Catch functions with too many branches\ncomplexipy . --max-complexity-allowed 15  # Catch deeply nested code\n</code></pre> <p>Ruff catches wide functions (many branches), while complexipy catches deep functions (heavy nesting). Together, they provide comprehensive complexity coverage.</p>"},{"location":"comparison-with-ruff/#configuration-examples","title":"Configuration Examples","text":""},{"location":"comparison-with-ruff/#ruff-configuration","title":"Ruff Configuration","text":"<pre><code># pyproject.toml\n[tool.ruff]\nselect = [\"PLR0912\"]\n\n[tool.ruff.pylint]\nmax-branches = 12\n</code></pre>"},{"location":"comparison-with-ruff/#complexipy-configuration","title":"complexipy Configuration","text":"<pre><code># pyproject.toml\n[tool.complexipy]\nmax-complexity-allowed = 15\n</code></pre>"},{"location":"comparison-with-ruff/#using-both-in-ci","title":"Using Both in CI","text":"<pre><code># .github/workflows/quality.yml\n- name: Ruff Linting\n  run: ruff check . --select=PLR0912\n\n- name: Cognitive Complexity Check\n  run: complexipy . --max-complexity-allowed 15\n</code></pre>"},{"location":"comparison-with-ruff/#migration-strategy","title":"Migration Strategy","text":"<p>If you're already using Ruff and want to add complexipy:</p> <ol> <li>Baseline First: Run <code>complexipy . --snapshot-create</code> to capture current state</li> <li>Set Thresholds: Start with a higher threshold (e.g., 20) and lower it over time</li> <li>Fix New Code: Only fail CI on new violations</li> <li>Gradual Improvement: Refactor legacy code opportunistically</li> </ol>"},{"location":"comparison-with-ruff/#summary","title":"Summary","text":"Feature Ruff PLR0912 complexipy Based on Cyclomatic Complexity Cognitive Complexity Counts nesting \u274c No \u2705 Yes else penalty \u2705 Yes \u274c No (only nesting) Boolean operators \u2705 Yes \u2705 Yes match statements \u2705 Yes Partial (content only) Best for Structural, testing, branch density How difficult code is to understand Threshold ~12 branches ~15 points Performance Fast (Rust) Very fast (Rust) <p>The Bottom Line: Ruff's PLR0912 measures structural complexity and branch density (useful for testing and analysis), while complexipy measures how difficult code is for humans to understand and maintain by penalizing nesting and flow breaks. Both are valuable, and using them together provides the best coverage for code quality.</p>"},{"location":"comparison-with-ruff/#further-reading","title":"Further Reading","text":"<ul> <li>Ruff Documentation</li> <li>Ruff PLR0912 Rule</li> <li>complexipy Understanding Scores</li> </ul>"},{"location":"understanding-scores/","title":"Understanding Complexity Scores","text":""},{"location":"understanding-scores/#what-do-the-numbers-mean","title":"What Do the Numbers Mean?","text":"<p>Cognitive complexity scores represent the mental effort required to understand a piece of code. Higher scores indicate code that is more difficult to comprehend and maintain.</p>"},{"location":"understanding-scores/#recommended-thresholds","title":"Recommended Thresholds","text":"Score Range Interpretation Recommendation 0-5 Simple Easy to understand, no action needed 6-10 Moderate Generally acceptable, but watch for further growth 11-15 Complex Consider refactoring if functionality is being added 16-25 High Refactoring recommended 26+ Very High Refactoring strongly recommended <p>Default Threshold</p> <p>complexipy uses a default threshold of 15. Functions exceeding this score will trigger warnings.</p>"},{"location":"understanding-scores/#how-complexity-is-calculated","title":"How Complexity is Calculated","text":"<p>Cognitive complexity is calculated by analyzing the Abstract Syntax Tree (AST) of your Python code and applying these rules:</p>"},{"location":"understanding-scores/#1-base-complexity-increments","title":"1. Base Complexity Increments","text":"<p>Each control flow structure adds to the complexity:</p> Structure Score Example <code>if</code> statement +1 <code>if condition:</code> <code>elif</code> clause +1 <code>elif other_condition:</code> <code>else</code> clause +0 <code>else:</code> (nesting only) <code>for</code> loop +1 <code>for item in items:</code> <code>while</code> loop +1 <code>while condition:</code> <code>except</code> handler +1 <code>except ValueError:</code> <code>finally</code> clause +0 <code>finally:</code> (nesting only) Ternary operator +1 <code>x if condition else y</code>"},{"location":"understanding-scores/#2-nesting-multiplier","title":"2. Nesting Multiplier","text":"<p>This is the key innovation: nested structures add extra complexity based on their depth.</p> <pre><code>def example():\n    if a:           # +1 (base)\n        if b:       # +2 (1 base + 1 nesting)\n            if c:   # +3 (1 base + 2 nesting)\n                pass\n# Total complexity: 6\n</code></pre> <p>The formula is: <code>complexity = 1 + nesting_level</code></p>"},{"location":"understanding-scores/#3-boolean-operators","title":"3. Boolean Operators","text":"<p>Complex logical conditions increase cognitive load:</p> <pre><code># Score: 3\ndef check(a, b, c):\n    if a and b or c:  # +1 (if) +2 (boolean operators)\n        return True\n</code></pre> <ul> <li>Each <code>and</code> or <code>or</code> operator: +1</li> <li>Operator type changes (mixing <code>and</code>/<code>or</code>): +1 additional</li> </ul>"},{"location":"understanding-scores/#4-special-cases","title":"4. Special Cases","text":"<p>Break and Continue <pre><code># Score: 3\nfor item in items:  # +1\n    if condition:   # +2 (1 + nesting)\n        break       # +0 (no additional score)\n</code></pre></p> <p>Match Statements (Python 3.10+) <pre><code># Score: 2\nmatch value:        # +0 (match itself doesn't count)\n    case 1:\n        if x:       # +1\n            pass\n    case 2:\n        if y:       # +1\n            pass\n</code></pre></p> <p>Recursion Recursive calls are analyzed but don't add extra complexity beyond their control structures.</p>"},{"location":"understanding-scores/#detailed-examples","title":"Detailed Examples","text":""},{"location":"understanding-scores/#example-1-simple-sequential-logic","title":"Example 1: Simple Sequential Logic","text":"<pre><code>def process_user(user):\n    if not user:              # +1\n        return None\n\n    if user.is_active:        # +1\n        send_welcome_email()\n\n    if user.needs_verification: # +1\n        send_verification()\n\n    return user\n# Total complexity: 3\n</code></pre> <p>Analysis: Three sequential if statements, no nesting. Easy to follow.</p>"},{"location":"understanding-scores/#example-2-nested-logic","title":"Example 2: Nested Logic","text":"<pre><code>def validate_order(order):\n    if order:                        # +1\n        if order.items:              # +2 (1 + nesting)\n            for item in order.items: # +3 (1 + nesting)\n                if item.quantity &gt; 0: # +4 (1 + nesting)\n                    process(item)\n    return False\n# Total complexity: 10\n</code></pre> <p>Analysis: Deep nesting creates exponential growth in cognitive load.</p>"},{"location":"understanding-scores/#example-3-complex-conditions","title":"Example 3: Complex Conditions","text":"<pre><code>def check_eligibility(user, product):\n    if user.age &gt;= 18 and user.verified and product.available: # +4\n        #  ^^^ if: +1, and operators: +2, total: +4\n        return True\n    return False\n# Total complexity: 4\n</code></pre> <p>Analysis: Multiple boolean operators increase the mental load of understanding the condition.</p>"},{"location":"understanding-scores/#example-4-exception-handling","title":"Example 4: Exception Handling","text":"<pre><code>def load_config(path):\n    try:                              # try itself: +0\n        with open(path) as f:         # +1 (context manager treated as if)\n            data = json.load(f)\n            if validate(data):        # +2 (1 + nesting)\n                return data\n    except FileNotFoundError:         # +1\n        create_default_config()\n    except json.JSONDecodeError:      # +1\n        log_error()\n    finally:                          # +0 (finally itself)\n        if log_enabled:               # +1\n            log(\"Config load attempted\")\n# Total complexity: 6\n</code></pre>"},{"location":"understanding-scores/#practical-guidelines","title":"Practical Guidelines","text":""},{"location":"understanding-scores/#what-should-i-refactor","title":"What Should I Refactor?","text":"<p>Focus on functions with scores above your threshold (default: 15). Common refactoring strategies:</p> <ol> <li>Extract Methods - Pull nested logic into separate functions</li> <li>Early Returns - Use guard clauses to reduce nesting</li> <li>Simplify Conditions - Break complex boolean expressions into named variables</li> <li>Strategy Pattern - Replace nested if/else with polymorphism</li> </ol>"},{"location":"understanding-scores/#example-refactoring","title":"Example Refactoring","text":"<p>Before (Complexity: 12) <pre><code>def process_order(order):\n    if order:                          # +1\n        if order.is_valid():           # +2\n            if order.payment:          # +3\n                if order.payment.process(): # +4\n                    ship_order(order)\n                else:\n                    refund(order)      # +0 (else clause)\n            else:\n                notify_payment_required() # Still nested\n        else:\n            log_invalid_order()\n    return False\n</code></pre></p> <p>After (Complexity: 4) <pre><code>def process_order(order):\n    if not order:                  # +1\n        return False\n\n    if not order.is_valid():       # +1\n        log_invalid_order()\n        return False\n\n    if not order.payment:          # +1\n        notify_payment_required()\n        return False\n\n    if order.payment.process():    # +1\n        ship_order(order)\n        return True\n\n    refund(order)\n    return False\n</code></pre></p> <p>Key improvements: - Reduced nesting from 4 levels to 1 - Complexity dropped from 12 to 4 - Logic is now linear and easier to follow</p>"},{"location":"understanding-scores/#score-interpretation-tips","title":"Score Interpretation Tips","text":"<ol> <li>Context Matters - A score of 20 might be acceptable for a complex algorithm but problematic for business logic</li> <li>Trend Over Time - Watch for increasing complexity in functions you modify frequently</li> <li>Relative Scores - Compare functions within the same codebase to identify outliers</li> <li>Team Agreement - Establish thresholds that work for your team and project</li> </ol>"},{"location":"understanding-scores/#further-reading","title":"Further Reading","text":"<ul> <li>SonarSource Cognitive Complexity White Paper</li> <li>Cyclomatic Complexity (McCabe, 1976)</li> </ul>"},{"location":"usage-guide/","title":"Usage Guide","text":"<p>This guide covers everything you need to know to effectively use complexipy in your Python projects.</p>"},{"location":"usage-guide/#installation","title":"Installation","text":"pipuvpoetry <pre><code>pip install complexipy\n</code></pre> <pre><code>uv add complexipy\n</code></pre> <pre><code>poetry add complexipy\n</code></pre>"},{"location":"usage-guide/#command-line-usage","title":"Command Line Usage","text":""},{"location":"usage-guide/#basic-analysis","title":"Basic Analysis","text":"<p>Analyze your entire project:</p> <pre><code>complexipy .\n</code></pre> <p>Analyze specific files or directories:</p> <pre><code>complexipy src/\ncomplexipy src/main.py\ncomplexipy src/ tests/\n</code></pre>"},{"location":"usage-guide/#setting-complexity-threshold","title":"Setting Complexity Threshold","text":"<p>The default threshold is 15. Functions exceeding this value will be highlighted:</p> <pre><code>complexipy . --max-complexity-allowed 10\n</code></pre>"},{"location":"usage-guide/#filtering-results","title":"Filtering Results","text":"<p>Show only functions that exceed the threshold:</p> <pre><code>complexipy . --failed\n</code></pre> <p>Suppress all output (useful for CI pipelines):</p> <pre><code>complexipy . --quiet\n</code></pre>"},{"location":"usage-guide/#sorting-results","title":"Sorting Results","text":"<p>Sort by complexity score:</p> <pre><code>complexipy . --sort asc   # Ascending (default)\ncomplexipy . --sort desc  # Descending\ncomplexipy . --sort name  # Alphabetically by function name\n</code></pre>"},{"location":"usage-guide/#excluding-files-and-directories","title":"Excluding Files and Directories","text":"<p>Exclude specific paths from analysis:</p> <pre><code># Exclude a directory\ncomplexipy . --exclude tests\n\n# Exclude multiple paths\ncomplexipy . --exclude tests --exclude migrations --exclude build\n\n# Exclude specific files\ncomplexipy . --exclude src/legacy/old_code.py\n</code></pre> <p>How exclusion works</p> <ul> <li>Entries resolve to existing directories (prefix match) or files (exact match)</li> <li>Non-existent entries are silently ignored</li> <li>Paths are relative to each provided root path</li> </ul>"},{"location":"usage-guide/#output-formats","title":"Output Formats","text":"<p>Save results to JSON or CSV:</p> <pre><code># JSON output (saved to complexipy-results.json)\ncomplexipy . --output-json\n\n# CSV output (saved to complexipy-results.csv)\ncomplexipy . --output-csv\n\n# Both\ncomplexipy . --output-json --output-csv\n</code></pre> <p>JSON Output Structure: <pre><code>{\n  \"files\": [\n    {\n      \"path\": \"src/main.py\",\n      \"complexity\": 42,\n      \"functions\": [\n        {\n          \"name\": \"process_data\",\n          \"complexity\": 18,\n          \"line_start\": 10,\n          \"line_end\": 45\n        }\n      ]\n    }\n  ],\n  \"total_complexity\": 42\n}\n</code></pre></p>"},{"location":"usage-guide/#color-output","title":"Color Output","text":"<p>Control color output:</p> <pre><code>complexipy . --color auto  # Default: auto-detect terminal support\ncomplexipy . --color yes   # Force colors\ncomplexipy . --color no    # Disable colors\n</code></pre>"},{"location":"usage-guide/#configuration-files","title":"Configuration Files","text":""},{"location":"usage-guide/#configuration-priority","title":"Configuration Priority","text":"<p>complexipy loads configuration in this order (highest to lowest priority):</p> <ol> <li>Command-line arguments</li> <li><code>complexipy.toml</code></li> <li><code>.complexipy.toml</code></li> <li><code>pyproject.toml</code> (under <code>[tool.complexipy]</code>)</li> </ol>"},{"location":"usage-guide/#example-configurations","title":"Example Configurations","text":"complexipy.tomlpyproject.toml.complexipy.toml <pre><code>paths = [\"src\", \"tests\"]\nmax-complexity-allowed = 10\nexclude = [\"migrations\", \"build\"]\nsnapshot-create = false\nsnapshot-ignore = false\nquiet = false\nignore-complexity = false\nfailed = false\ncolor = \"auto\"\nsort = \"asc\"\noutput-csv = false\noutput-json = false\n</code></pre> <pre><code>[tool.complexipy]\npaths = [\"src\", \"tests\"]\nmax-complexity-allowed = 10\nexclude = [\"migrations\", \"build\"]\nfailed = true\nsort = \"desc\"\n</code></pre> <pre><code># Hidden config file for team-specific settings\nmax-complexity-allowed = 15\nexclude = [\"venv\", \".venv\", \"node_modules\"]\n</code></pre>"},{"location":"usage-guide/#python-api","title":"Python API","text":""},{"location":"usage-guide/#analyzing-files","title":"Analyzing Files","text":"<pre><code>from complexipy import file_complexity\n\n# Analyze a file\nresult = file_complexity(\"src/main.py\")\n\nprint(f\"Total complexity: {result.complexity}\")\nprint(f\"File path: {result.path}\")\n\n# Iterate over functions\nfor func in result.functions:\n    print(f\"{func.name}:\")\n    print(f\"  Complexity: {func.complexity}\")\n    print(f\"  Lines: {func.line_start}-{func.line_end}\")\n</code></pre>"},{"location":"usage-guide/#analyzing-code-strings","title":"Analyzing Code Strings","text":"<pre><code>from complexipy import code_complexity\n\n# Analyze code snippet\ncode = \"\"\"\ndef calculate_discount(price, customer):\n    if customer.is_premium:\n        if price &gt; 100:\n            return price * 0.8\n        else:\n            return price * 0.9\n    return price\n\"\"\"\n\nresult = code_complexity(code)\nprint(f\"Complexity: {result.complexity}\")\n\nfor func in result.functions:\n    print(f\"{func.name}: {func.complexity}\")\n</code></pre>"},{"location":"usage-guide/#practical-api-usage","title":"Practical API Usage","text":"<p>Example: Pre-commit Hook</p> <pre><code>#!/usr/bin/env python3\n\"\"\"Check complexity of staged Python files.\"\"\"\nimport sys\nfrom pathlib import Path\nfrom complexipy import file_complexity\n\nMAX_COMPLEXITY = 15\n\ndef main():\n    # Get staged Python files (integrate with git)\n    staged_files = get_staged_python_files()\n\n    violations = []\n    for filepath in staged_files:\n        result = file_complexity(str(filepath))\n\n        for func in result.functions:\n            if func.complexity &gt; MAX_COMPLEXITY:\n                violations.append({\n                    'file': filepath,\n                    'function': func.name,\n                    'complexity': func.complexity,\n                    'line': func.line_start\n                })\n\n    if violations:\n        print(\"Complexity violations found:\")\n        for v in violations:\n            print(f\"  {v['file']}:{v['line']} - \"\n                  f\"{v['function']} (complexity: {v['complexity']})\")\n        sys.exit(1)\n\n    print(\"All functions pass complexity check!\")\n    sys.exit(0)\n\nif __name__ == \"__main__\":\n    main()\n</code></pre> <p>Example: Code Quality Dashboard</p> <pre><code>from pathlib import Path\nfrom complexipy import file_complexity\nimport json\n\ndef analyze_project(root_path: str):\n    \"\"\"Generate complexity report for entire project.\"\"\"\n    project = Path(root_path)\n    results = []\n\n    for py_file in project.rglob(\"*.py\"):\n        if \"venv\" in str(py_file) or \".venv\" in str(py_file):\n            continue\n\n        try:\n            result = file_complexity(str(py_file))\n            results.append({\n                'file': str(py_file),\n                'complexity': result.complexity,\n                'functions': [\n                    {\n                        'name': f.name,\n                        'complexity': f.complexity,\n                        'line_start': f.line_start,\n                        'line_end': f.line_end\n                    }\n                    for f in result.functions\n                ]\n            })\n        except Exception as e:\n            print(f\"Error analyzing {py_file}: {e}\")\n\n    # Sort by complexity\n    results.sort(key=lambda x: x['complexity'], reverse=True)\n\n    # Save report\n    with open(\"complexity-report.json\", \"w\") as f:\n        json.dump(results, f, indent=2)\n\n    # Print summary\n    total_files = len(results)\n    total_complexity = sum(r['complexity'] for r in results)\n    avg_complexity = total_complexity / total_files if total_files else 0\n\n    print(f\"Analyzed {total_files} files\")\n    print(f\"Total complexity: {total_complexity}\")\n    print(f\"Average complexity: {avg_complexity:.2f}\")\n\n    # Top 10 most complex files\n    print(\"\\nTop 10 most complex files:\")\n    for r in results[:10]:\n        print(f\"  {r['file']}: {r['complexity']}\")\n\nif __name__ == \"__main__\":\n    analyze_project(\"./src\")\n</code></pre>"},{"location":"usage-guide/#snapshot-baselines","title":"Snapshot Baselines","text":"<p>Snapshots allow you to adopt complexipy gradually in large, existing codebases.</p>"},{"location":"usage-guide/#creating-a-snapshot","title":"Creating a Snapshot","text":"<pre><code>complexipy . --snapshot-create --max-complexity-allowed 15\n</code></pre> <p>This creates <code>complexipy-snapshot.json</code> in your working directory, recording all functions that currently exceed the threshold.</p>"},{"location":"usage-guide/#how-snapshots-work","title":"How Snapshots Work","text":"<p>Once a snapshot exists, complexipy will:</p> <ul> <li>\u2705 Pass: Functions that were already in the snapshot and haven't gotten worse</li> <li>\u2705 Pass: Functions that improved (automatically removed from snapshot)</li> <li>\u274c Fail: New functions that exceed the threshold</li> <li>\u274c Fail: Tracked functions that got more complex</li> </ul>"},{"location":"usage-guide/#using-snapshots-in-ci","title":"Using Snapshots in CI","text":"<pre><code># .github/workflows/complexity.yml\nname: Complexity Check\n\non: [push, pull_request]\n\njobs:\n  check:\n    runs-on: ubuntu-latest\n    steps:\n      - uses: actions/checkout@v4\n\n      - name: Install complexipy\n        run: pip install complexipy\n\n      - name: Check complexity\n        run: complexipy . --max-complexity-allowed 15\n</code></pre> <p>The snapshot file (<code>complexipy-snapshot.json</code>) should be committed to version control.</p>"},{"location":"usage-guide/#ignoring-snapshots","title":"Ignoring Snapshots","text":"<p>Temporarily disable snapshot checking:</p> <pre><code>complexipy . --snapshot-ignore\n</code></pre> <p>Use this when: - Refactoring multiple files at once - Regenerating the baseline - Testing different thresholds</p>"},{"location":"usage-guide/#snapshot-file-format","title":"Snapshot File Format","text":"<pre><code>{\n  \"version\": \"1.0\",\n  \"threshold\": 15,\n  \"functions\": {\n    \"src/legacy.py::old_function\": {\n      \"complexity\": 23,\n      \"line_start\": 10,\n      \"line_end\": 50\n    }\n  }\n}\n</code></pre>"},{"location":"usage-guide/#inline-ignores","title":"Inline Ignores","text":"<p>Suppress complexity warnings for specific functions:</p> <pre><code>def complex_legacy_function():  # noqa: complexipy\n    # Complex logic that can't be refactored yet\n    pass\n\n# Or with a reason\ndef another_complex_function():  # noqa: complexipy (technical debt: issue #123)\n    pass\n</code></pre> <p>The ignore comment can also be on the line above:</p> <pre><code># noqa: complexipy\ndef complex_function():\n    pass\n</code></pre> <p>Use Sparingly</p> <p>Inline ignores should be temporary. Document why the complexity is necessary and track technical debt.</p>"},{"location":"usage-guide/#cicd-integration","title":"CI/CD Integration","text":""},{"location":"usage-guide/#github-actions","title":"GitHub Actions","text":"<p>Use the official action:</p> <pre><code>- uses: rohaquinlop/complexipy-action@v2\n  with:\n    paths: src tests\n    max_complexity_allowed: 15\n    output_json: true\n</code></pre> <p>Or run directly:</p> <pre><code>- name: Check complexity\n  run: |\n    pip install complexipy\n    complexipy . --max-complexity-allowed 15\n</code></pre>"},{"location":"usage-guide/#pre-commit-hook","title":"Pre-commit Hook","text":"<p>Add to <code>.pre-commit-config.yaml</code>:</p> <pre><code>repos:\n  - repo: https://github.com/rohaquinlop/complexipy-pre-commit\n    rev: v4.2.0\n    hooks:\n      - id: complexipy\n        args: [--max-complexity-allowed=15]\n</code></pre>"},{"location":"usage-guide/#gitlab-ci","title":"GitLab CI","text":"<pre><code>complexity:\n  image: python:3.11\n  script:\n    - pip install complexipy\n    - complexipy . --max-complexity-allowed 15\n  only:\n    - merge_requests\n    - main\n</code></pre>"},{"location":"usage-guide/#vs-code-integration","title":"VS Code Integration","text":"<p>Install the complexipy extension for real-time complexity analysis:</p> <ul> <li>Inline complexity scores</li> <li>Hover tooltips with details</li> <li>Color-coded indicators</li> <li>Quick-fix suggestions</li> </ul>"},{"location":"usage-guide/#tips-and-best-practices","title":"Tips and Best Practices","text":""},{"location":"usage-guide/#1-start-with-high-thresholds","title":"1. Start with High Thresholds","text":"<p>When introducing complexipy to an existing codebase:</p> <pre><code># Create baseline\ncomplexipy . --snapshot-create --max-complexity-allowed 25\n\n# Gradually lower threshold over time\ncomplexipy . --max-complexity-allowed 20\ncomplexipy . --max-complexity-allowed 15\n</code></pre>"},{"location":"usage-guide/#2-focus-on-high-traffic-code","title":"2. Focus on High-Traffic Code","text":"<p>Not all complex code needs immediate refactoring:</p> <pre><code># Focus on frequently changed files\ncomplexipy src/core/ --max-complexity-allowed 10\ncomplexipy src/legacy/ --max-complexity-allowed 25\n</code></pre>"},{"location":"usage-guide/#3-use-with-code-reviews","title":"3. Use with Code Reviews","text":"<pre><code># Check only files in current branch\ngit diff --name-only main | grep '.py$' | xargs complexipy\n</code></pre>"},{"location":"usage-guide/#4-combine-with-test-coverage","title":"4. Combine with Test Coverage","text":"<p>High complexity + low coverage = high risk</p> <pre><code># Check coverage for complex functions\npytest --cov=src --cov-report=term-missing\ncomplexipy src/ --failed\n</code></pre>"},{"location":"usage-guide/#5-track-trends","title":"5. Track Trends","text":"<pre><code># Generate historical data\ncomplexipy . --output-json\n# Commit complexipy-results.json to track changes over time\n</code></pre>"},{"location":"usage-guide/#troubleshooting","title":"Troubleshooting","text":""},{"location":"usage-guide/#no-python-files-found","title":"No Python files found","text":"<p>Ensure you're in the correct directory and your files have <code>.py</code> extensions.</p>"},{"location":"usage-guide/#syntax-errors-in-analyzed-files","title":"Syntax errors in analyzed files","text":"<p>complexipy requires valid Python syntax. Fix syntax errors first:</p> <pre><code>python -m py_compile file.py\n</code></pre>"},{"location":"usage-guide/#performance-issues-on-large-codebases","title":"Performance issues on large codebases","text":"<p>Exclude unnecessary directories:</p> <pre><code>complexipy . --exclude venv --exclude .venv --exclude node_modules\n</code></pre>"},{"location":"usage-guide/#different-results-than-expected","title":"Different results than expected","text":"<p>Check configuration file precedence. Use <code>--help</code> to see active configuration:</p> <pre><code>complexipy --help\n</code></pre>"},{"location":"usage-guide/#next-steps","title":"Next Steps","text":"<ul> <li>Read Understanding Complexity Scores to interpret results</li> <li>See Comparison with Ruff for complementary tooling</li> <li>Check out About complexipy to learn more about the project</li> </ul>"}]}